"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getThemeProperty = exports.getThemeFontFamily = exports.getThemeColor = exports.getFontWeight = exports.createSpacingStyles = exports.createShadowStyles = exports.createPositionStyle = exports.createFlexStyles = exports.createBorderWidthStyles = exports.createBorderRadiusStyles = exports.createBorderColorStyles = void 0;

var _utilities = require("../utilities");

/**
 * create spacing styles from object of style props passed to magnus component
 *
 * m="10", mt="xl"
 *
 * @param value
 * @param theme
 */
const createSpacingStyles = (props, theme) => {
  let propKeys;
  propKeys = {
    p: 'padding',
    pt: 'paddingTop',
    pr: 'paddingRight',
    pb: 'paddingBottom',
    pl: 'paddingLeft',
    px: 'paddingHorizontal',
    py: 'paddingVertical',
    ps: 'paddingStart',
    m: 'margin',
    mt: 'marginTop',
    mr: 'marginRight',
    mb: 'marginBottom',
    ml: 'marginLeft',
    mx: 'marginHorizontal',
    my: 'marginVertical',
    ms: 'marginStart'
  };
  const computedStyle = {};
  Object.keys(propKeys).map(propKey => {
    const styleProperty = propKeys[propKey];

    if (propKey in props) {
      computedStyle[styleProperty] = getThemeProperty(theme, props[propKey]);
    }
  });
  return computedStyle;
};
/**
 * get font weight font
 *
 * @param
 * @param fontFamily
 * @param fontWeight
 */


exports.createSpacingStyles = createSpacingStyles;

const getFontWeight = (themeFontFamily, fontFamily, fontWeight) => {
  if (fontFamily === '' || !fontWeight) {
    return fontWeight;
  }

  if (themeFontFamily) {
    if (typeof themeFontFamily[fontWeight] !== 'undefined') {
      return 'normal';
    }
  }

  if (!fontFamily) {
    return fontWeight;
  }

  return 'normal';
};
/**
 * extract the fontFamily from theme

 * @param themeFontFamily
 * @param fontWeight
 */


exports.getFontWeight = getFontWeight;

const getThemeFontFamily = function (themeFontFamily) {
  let fontWeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'normal';

  if (themeFontFamily) {
    if (typeof themeFontFamily[fontWeight] !== 'undefined') {
      return themeFontFamily[fontWeight];
    }
  }

  return undefined;
};
/**
 * extract the theme property from theme
 * if thereis no theme property in the value, return the value
 *
 * @param themeColors
 * @param value
 */


exports.getThemeFontFamily = getThemeFontFamily;

const getThemeColor = (themeColors, value) => {
  if (themeColors && value) {
    if (typeof themeColors[value] !== 'undefined') {
      if ((0, _utilities.isValidColor)(themeColors[value])) {
        return themeColors[value];
      }

      return getThemeColor(themeColors, themeColors[value]);
    }
  }

  return value;
};
/**
 * extract the theme property from theme
 * if thereis no theme property in the value, return the value
 *
 * @param theme
 * @param value
 */


exports.getThemeColor = getThemeColor;

const getThemeProperty = (theme, value) => {
  if (theme) {
    if (typeof theme[value] !== 'undefined') {
      return theme[value];
    }
  }

  return value;
};
/**
 * borderRadius="xl"
 *
 * @param value
 * @param theme
 */


exports.getThemeProperty = getThemeProperty;

const createBorderRadiusStyles = (props, theme) => {
  let propKeys;
  propKeys = {
    rounded: 'borderRadius',
    roundedTopLeft: 'borderTopLeftRadius',
    roundedTopRight: 'borderTopRightRadius',
    roundedBottomLeft: 'borderBottomLeftRadius',
    roundedBottomRight: 'borderBottomRightRadius',
    roundedTop: ['borderTopLeftRadius', 'borderTopRightRadius'],
    roundedLeft: ['borderTopLeftRadius', 'borderBottomLeftRadius'],
    roundedRight: ['borderTopRightRadius', 'borderBottomRightRadius'],
    roundedBottom: ['borderBottomLeftRadius', 'borderBottomRightRadius']
  };
  const computedStyle = {};
  Object.keys(propKeys).map(propKey => {
    const styleProperty = propKeys[propKey];

    if (propKey in props) {
      if (styleProperty instanceof Array) {
        styleProperty.forEach(property => {
          computedStyle[property] = getThemeProperty(theme, props[propKey]);
        });
      } else {
        computedStyle[styleProperty] = getThemeProperty(theme, props[propKey]);
      }
    }
  });
  return computedStyle;
};
/**
 * adds flex property in styles
 *
 * @param props
 */


exports.createBorderRadiusStyles = createBorderRadiusStyles;

const createFlexStyles = props => {
  let propKeys;
  propKeys = {
    flex: 'flex'
  };
  const computedStyle = {};
  Object.keys(propKeys).map(propKey => {
    const styleProperty = propKeys[propKey];

    if (propKey in props) {
      computedStyle[styleProperty] = props[propKey];
    }
  });
  return computedStyle;
};
/**
 * create borderWidth styles
 *
 * @param value
 */


exports.createFlexStyles = createFlexStyles;

const createBorderWidthStyles = props => {
  let propKeys;
  propKeys = {
    borderWidth: 'borderWidth',
    borderStartWidth: 'borderStartWidth',
    borderEndWidth: 'borderEndWidth',
    borderTopWidth: 'borderTopWidth',
    borderLeftWidth: 'borderLeftWidth',
    borderRightWidth: 'borderRightWidth',
    borderBottomWidth: 'borderBottomWidth'
  };
  const computedStyle = {};
  Object.keys(propKeys).map(propKey => {
    const styleProperty = propKeys[propKey];

    if (propKey in props) {
      computedStyle[styleProperty] = props[propKey];
    }
  });
  return computedStyle;
};
/**
 * create borderRadius styles
 *
 * @param value
 */


exports.createBorderWidthStyles = createBorderWidthStyles;

const createBorderColorStyles = (props, theme) => {
  let propKeys;
  propKeys = {
    borderColor: 'borderColor',
    borderTopColor: 'borderTopColor',
    borderRightColor: 'borderRightColor',
    borderLeftColor: 'borderLeftColor',
    borderBottomColor: 'borderBottomColor'
  };
  const computedStyle = {};
  Object.keys(propKeys).map(propKey => {
    const styleProperty = propKeys[propKey];

    if (propKey in props) {
      if (styleProperty instanceof Array) {
        styleProperty.forEach(property => {
          computedStyle[property] = getThemeColor(theme, props[propKey]);
        });
      } else {
        computedStyle[styleProperty] = getThemeColor(theme, props[propKey]);
      }
    }
  });
  return computedStyle;
};
/**
 * adds shadows property in styles
 *
 * @param props
 */


exports.createBorderColorStyles = createBorderColorStyles;

const createShadowStyles = (props, theme) => {
  let computedStyle = {};

  if (props.shadow) {
    computedStyle = { ...(theme.shadow && theme.shadow[props.shadow]),
      shadowColor: getThemeColor(theme.colors, props.shadowColor)
    };
  }

  return computedStyle;
};
/**
 * position="absolute"
 * top={10}
 *
 * @param value
 */


exports.createShadowStyles = createShadowStyles;

const createPositionStyle = props => {
  let propKeys;
  propKeys = {
    position: 'position',
    top: 'top',
    left: 'left',
    right: 'right',
    bottom: 'bottom'
  };
  const computedStyle = {};
  Object.keys(propKeys).map(propKey => {
    const styleProperty = propKeys[propKey];

    if (propKey in props) {
      computedStyle[styleProperty] = props[propKey];
    }
  });
  return computedStyle;
};

exports.createPositionStyle = createPositionStyle;
//# sourceMappingURL=theme.service.js.map