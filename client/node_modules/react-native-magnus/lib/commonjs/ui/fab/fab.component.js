"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Fab = void 0;

var React = _interopRequireWildcard(require("react"));

var _reactNative = require("react-native");

var _color = _interopRequireDefault(require("color"));

var _theme = require("../../theme/theme.service");

var _fab = require("./fab.style");

var _theme2 = require("../../theme");

var _button = require("../button/button.component");

var _icon = require("../icon/icon.component");

var _withDefaultProps = require("../../utilities/withDefaultProps");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class FabBase extends React.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "animation", void 0);

    _defineProperty(this, "fadeAnimation", void 0);

    _defineProperty(this, "visibleAnimation", void 0);

    _defineProperty(this, "actionsAnimation", void 0);

    _defineProperty(this, "mainBottomAnimation", void 0);

    _defineProperty(this, "actionsBottomAnimation", void 0);

    _defineProperty(this, "getIcon", () => {
      const {
        active
      } = this.state;
      const {
        icon,
        color: colorProp,
        fontSize,
        activeIcon
      } = this.props;

      if (active === false) {
        if (typeof icon === 'string') {
          return /*#__PURE__*/React.createElement(_icon.Icon, {
            name: icon,
            fontSize: fontSize,
            color: colorProp
          });
        }

        if ( /*#__PURE__*/React.isValidElement(icon)) {
          return icon;
        }
      } else {
        if (typeof activeIcon === 'string') {
          return /*#__PURE__*/React.createElement(_icon.Icon, {
            name: activeIcon,
            fontSize: fontSize,
            color: colorProp
          });
        }

        if ( /*#__PURE__*/React.isValidElement(activeIcon)) {
          return activeIcon;
        }
      }

      return false;
    });

    _defineProperty(this, "reset", () => {
      const {
        animated,
        onClose,
        h,
        bottom,
        useNativeDriver = false
      } = this.props;

      if (animated) {
        _reactNative.Animated.spring(this.animation, {
          toValue: 0,
          useNativeDriver: useNativeDriver
        }).start();

        _reactNative.Animated.spring(this.actionsAnimation, {
          toValue: 0,
          useNativeDriver
        }).start();

        _reactNative.Animated.spring(this.actionsBottomAnimation, {
          toValue: (h ?? 40) + (bottom ?? 40),
          useNativeDriver
        }).start();
      }

      this.updateState({
        active: false
      }, () => {
        if (onClose) {
          onClose();
        }
      });
    });

    _defineProperty(this, "animateButton", () => {
      const {
        animated,
        onOpen,
        h,
        bottom,
        useNativeDriver = false
      } = this.props;
      const {
        active
      } = this.state;

      if (!active) {
        if (animated) {
          _reactNative.Animated.spring(this.animation, {
            toValue: 1,
            useNativeDriver
          }).start();
        }

        if (animated) {
          _reactNative.Animated.spring(this.actionsAnimation, {
            toValue: 1,
            useNativeDriver
          }).start();

          _reactNative.Animated.spring(this.actionsBottomAnimation, {
            toValue: (h ?? 40) + (bottom ?? 40) + 20,
            useNativeDriver
          }).start(); // only execute it for the background to prevent extra calls


          _reactNative.LayoutAnimation.configureNext({
            duration: 180,
            create: {
              type: _reactNative.LayoutAnimation.Types.easeInEaseOut,
              property: _reactNative.LayoutAnimation.Properties.opacity
            }
          });
        }

        this.updateState({
          active: true
        }, () => {
          if (onOpen) {
            onOpen();
          }
        });
      } else {
        this.reset();
      }
    });

    _defineProperty(this, "updateState", (nextState, callback) => {
      this.setState(nextState, () => {
        if (callback) {
          callback();
        }
      });
    });

    _defineProperty(this, "handlePressBackdrop", () => {
      const {
        onPressBackdrop
      } = this.props;

      if (onPressBackdrop) {
        onPressBackdrop();
      }

      this.reset();
    });

    _defineProperty(this, "handlePressItem", () => {
      this.reset();
    });

    _defineProperty(this, "renderMainButton", computedStyles => {
      const {
        animated,
        position,
        right,
        bottom,
        // shadow,
        // shadowColor,
        ...rest
      } = this.props;
      const {
        active
      } = this.state;
      let animatedViewStyle;
      let animatedVisibleView;

      if (animated) {
        animatedVisibleView = {
          opacity: this.fadeAnimation
        };
        animatedViewStyle = {
          opacity: this.fadeAnimation,
          transform: [{
            rotate: this.animation.interpolate({
              inputRange: [0, 1],
              outputRange: ['0deg', '180deg']
            })
          }]
        };
      } else if (active) {
        animatedVisibleView = {};
        animatedViewStyle = {
          opacity: this.fadeAnimation,
          transform: [{
            rotate: '45deg'
          }]
        };
      } else {
        animatedVisibleView = {};
        animatedViewStyle = {
          transform: [{
            rotate: '0deg'
          }]
        };
      }

      return /*#__PURE__*/React.createElement(_reactNative.Animated.View, {
        style: [computedStyles.button, animatedVisibleView],
        accessible: true,
        accessibilityLabel: "Floating Action Button"
      }, /*#__PURE__*/React.createElement(_button.Button, _extends({
        mb: bottom,
        mr: right,
        onPress: this.animateButton
      }, rest), /*#__PURE__*/React.createElement(_reactNative.Animated.View, {
        style: [animatedViewStyle]
      }, this.getIcon())));
    });

    _defineProperty(this, "renderActions", computedStyle => {
      const {
        animated,
        right,
        children
      } = this.props;
      const {
        active
      } = this.state;
      let animatedActionsStyle;

      if (animated) {
        animatedActionsStyle = {
          opacity: this.actionsAnimation.interpolate({
            inputRange: [0, 1],
            outputRange: [0, 1]
          })
        };
      } else {
        animatedActionsStyle = {
          opacity: active ? 1 : 0
        };
      }

      const actionsStyles = [computedStyle.actions, animatedActionsStyle, {
        right,
        bottom: this.actionsBottomAnimation
      }];
      return /*#__PURE__*/React.createElement(_reactNative.Animated.View, {
        style: actionsStyles,
        pointerEvents: "box-none"
      }, React.Children.map(children, child => {
        return /*#__PURE__*/React.cloneElement(child, {
          mb: child.props.mb ? child.props.mb : 'lg',
          onPress: e => {
            // if fab is not active, don't allow pressing buttons
            if (!active) {
              return;
            }

            if (child.props.onPress) {
              child.props.onPress(e);
            }

            this.reset();
          }
        });
      }));
    });

    _defineProperty(this, "renderTappableBackground", (theme, computedStyle) => {
      const {
        overlayColor,
        overlayOpacity
      } = this.props;
      const calculatedOverlayColor = (0, _color.default)((0, _theme.getThemeColor)(theme.colors, overlayColor)).alpha(overlayOpacity ?? 1).rgb().string(); // TouchableOpacity don't require a child

      return /*#__PURE__*/React.createElement(_reactNative.TouchableOpacity, {
        activeOpacity: 1,
        style: [computedStyle.overlay, {
          backgroundColor: calculatedOverlayColor
        }],
        onPress: this.handlePressBackdrop
      });
    });

    this.state = {
      active: false
    };
    this.mainBottomAnimation = new _reactNative.Animated.Value(props.bottom ?? 0);
    this.actionsBottomAnimation = new _reactNative.Animated.Value((props.h ?? 40) + (props.bottom ?? 40) + 30);
    this.animation = new _reactNative.Animated.Value(0);
    this.actionsAnimation = new _reactNative.Animated.Value(0);
    this.visibleAnimation = new _reactNative.Animated.Value(0);
    this.fadeAnimation = new _reactNative.Animated.Value(1);
  }

  componentDidMount() {
    const {
      openOnMount
    } = this.props;

    if (openOnMount) {
      this.animateButton();
    }
  }

  render() {
    const {
      active
    } = this.state;
    const {
      showBackground
    } = this.props;
    return /*#__PURE__*/React.createElement(_theme2.ThemeContext.Consumer, null, _ref => {
      let {
        theme
      } = _ref;
      const computedStyle = (0, _fab.getStyle)(theme, this.props);
      return /*#__PURE__*/React.createElement(_reactNative.Animated.View, {
        pointerEvents: 'box-none',
        style: computedStyle.overlay
      }, active && showBackground && this.renderTappableBackground(theme, computedStyle), this.renderActions(computedStyle), this.renderMainButton(computedStyle));
    });
  }

}

const Fab = (0, _withDefaultProps.withDefaultProps)(FabBase, 'Fab', {
  color: 'white',
  fontSize: '4xl',
  p: 18,
  overlayColor: 'gray900',
  overlayOpacity: 0.5,
  position: 'absolute',
  openOnMount: false,
  showBackground: true,
  animated: true,
  bottom: 30,
  right: 30,
  icon: 'plus',
  activeIcon: 'close',
  rounded: 'circle',
  bg: 'blue500',
  useNativeDriver: false,
  shadow: 'lg',
  shadowColor: 'gray900'
});
exports.Fab = Fab;
//# sourceMappingURL=fab.component.js.map