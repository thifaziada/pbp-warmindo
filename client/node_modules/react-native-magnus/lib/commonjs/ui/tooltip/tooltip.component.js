"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tooltip = void 0;

var React = _interopRequireWildcard(require("react"));

var _reactNative = require("react-native");

var _tooltip = require("./tooltip.style");

var _theme = require("../../theme");

var _text = require("../text/text.component");

var _triangle = require("./triangle.component");

var _utilities = require("../../utilities");

var _useDefaultProps = require("../../utilities/useDefaultProps");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const STATES = {
  HIDDEN: 'HIDDEN',
  ANIMATING: 'ANIMATING',
  SHOWN: 'SHOWN'
};

const EASING = _reactNative.Easing.bezier(0.4, 0, 0.2, 1);

const SCREEN_INDENT = 8;
const Tooltip = /*#__PURE__*/React.forwardRef((incomingProps, ref) => {
  const props = (0, _useDefaultProps.useDefaultProps)('Tooltip', incomingProps, {
    animationDuration: 300,
    bg: 'gray900',
    color: 'white',
    p: 'md',
    rounded: 'xl',
    mx: 'lg',
    minW: 50,
    zIndex: 1,
    fontSize: 'md',
    useNativeDriver: false
  });
  const container = (0, React.useRef)(null);
  const [state, setState] = (0, _utilities.useStateCallback)({
    visible: STATES.HIDDEN,
    top: 0,
    left: 0,
    menuWidth: 0,
    menuHeight: 0,
    buttonWidth: 0,
    buttonHeight: 0,
    marginAnimation: new _reactNative.Animated.Value(-8),
    opacityAnimation: new _reactNative.Animated.Value(0)
  });
  const {
    visible,
    menuHeight,
    buttonHeight,
    opacityAnimation,
    marginAnimation
  } = state;
  let {
    top
  } = state;
  const windowHeight = _utilities.WINDOW_HEIGHT - (_reactNative.StatusBar.currentHeight ?? 0);
  let invert = false;

  if (top + menuHeight + buttonHeight + SCREEN_INDENT > windowHeight) {
    top = top - menuHeight - SCREEN_INDENT;
    invert = true;
  } else if (top < SCREEN_INDENT) {
    top = SCREEN_INDENT + buttonHeight;
  } else {
    top = top + buttonHeight + SCREEN_INDENT;
    invert = false;
  }

  const shadowMenuContainerStyle = {
    opacity: opacityAnimation,
    top,
    marginTop: marginAnimation
  };
  const {
    text,
    style,
    children,
    bg,
    animationDuration,
    useNativeDriver,
    ...rest
  } = props;
  const animationStarted = visible === STATES.ANIMATING;
  const modalVisible = visible === STATES.SHOWN || animationStarted;
  const {
    theme
  } = (0, _theme.useTheme)();
  const computedStyle = (0, _tooltip.getStyle)(theme, props, { ...state,
    invert
  });
  /**
   * on dismissal of tooltip
   *
   * TODO: add onDismiss event
   */

  const onDismiss = () => {};
  /**
   * shows the tooltip
   */


  const show = () => {
    if (container.current) {
      container.current.measureInWindow((left, top, buttonWidth, buttonHeight) => {
        setState({ ...state,
          buttonHeight,
          buttonWidth,
          left,
          visible: STATES.SHOWN,
          top
        }, () => {
          _reactNative.Animated.parallel([_reactNative.Animated.timing(state.marginAnimation, {
            toValue: 0,
            duration: animationDuration,
            easing: EASING,
            useNativeDriver: useNativeDriver
          }), _reactNative.Animated.timing(state.opacityAnimation, {
            toValue: 1,
            duration: animationDuration,
            easing: EASING,
            useNativeDriver: useNativeDriver
          })]).start();
        });
      });
    }
  };
  /**
   * hides the tooltip
   *
   * @param onHidden
   */


  const hide = () => {
    _reactNative.Animated.timing(state.opacityAnimation, {
      toValue: 0,
      duration: animationDuration,
      easing: EASING,
      useNativeDriver: useNativeDriver
    }).start(() => {
      setState({ ...state,
        visible: STATES.HIDDEN,
        marginAnimation: new _reactNative.Animated.Value(-8),
        opacityAnimation: new _reactNative.Animated.Value(0)
      });
    });
  };
  /**
   * exposing functions to parent
   */


  (0, React.useImperativeHandle)(ref, () => ({
    show() {
      show();
    },

    hide() {
      hide();
    }

  }));
  return /*#__PURE__*/React.createElement(_reactNative.View, {
    ref: container,
    onLayout: () => null
  }, /*#__PURE__*/React.createElement(_reactNative.View, null, children), /*#__PURE__*/React.createElement(_reactNative.Modal, {
    visible: modalVisible,
    onRequestClose: hide,
    supportedOrientations: ['portrait', 'portrait-upside-down', 'landscape', 'landscape-left', 'landscape-right'],
    transparent: true,
    onDismiss: onDismiss
  }, /*#__PURE__*/React.createElement(_reactNative.TouchableWithoutFeedback, {
    onPress: hide,
    accessible: false
  }, /*#__PURE__*/React.createElement(_reactNative.View, {
    style: _reactNative.StyleSheet.absoluteFill
  }, /*#__PURE__*/React.createElement(_reactNative.Animated.View, {
    style: [styles.shadowMenuContainer, shadowMenuContainerStyle, style]
  }, /*#__PURE__*/React.createElement(_triangle.Triangle, {
    invert: invert,
    style: computedStyle.triangle
  }), /*#__PURE__*/React.createElement(_reactNative.Animated.View, {
    style: computedStyle.container
  }, typeof text === 'string' ? /*#__PURE__*/React.createElement(_text.Text, rest, text) : text))))));
}); // Tooltip.defaultProps = {
//   animationDuration: 300,
//   bg: 'gray900',
//   color: 'white',
//   p: 'md',
//   rounded: 'xl',
//   mx: 'lg',
//   minW: 50,
//   zIndex: 1,
//   fontSize: 'md',
//   useNativeDriver: false,
// };

exports.Tooltip = Tooltip;

const styles = _reactNative.StyleSheet.create({
  shadowMenuContainer: {
    position: 'absolute',
    backgroundColor: 'transparent',
    borderRadius: 4,
    opacity: 0,
    width: '100%'
  },
  menuContainer: {
    overflow: 'hidden'
  }
});
//# sourceMappingURL=tooltip.component.js.map