"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Host = exports.Context = void 0;

var React = _interopRequireWildcard(require("react"));

var _reactNative = require("react-native");

var _useKey = require("./hooks/useKey");

var _manager = require("./manager.component");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const Context = /*#__PURE__*/React.createContext(null);
exports.Context = Context;

const Host = _ref => {
  let {
    children,
    style
  } = _ref;
  const managerRef = React.useRef(null);
  const queue = [];
  const {
    generateKey,
    removeKey
  } = (0, _useKey.useKey)();
  React.useEffect(() => {
    var _managerRef$current, _managerRef$current2, _managerRef$current3;

    while (queue.length && managerRef.current) {
      const action = queue.pop();

      if (action) {
        switch (action.type) {
          case 'mount':
            (_managerRef$current = managerRef.current) === null || _managerRef$current === void 0 ? void 0 : _managerRef$current.mount(action.key, action.children);
            break;

          case 'update':
            (_managerRef$current2 = managerRef.current) === null || _managerRef$current2 === void 0 ? void 0 : _managerRef$current2.update(action.key, action.children);
            break;

          case 'unmount':
            (_managerRef$current3 = managerRef.current) === null || _managerRef$current3 === void 0 ? void 0 : _managerRef$current3.unmount(action.key);
            break;
        }
      }
    }
  }, []);

  const mount = children => {
    const key = generateKey();

    if (managerRef.current) {
      managerRef.current.mount(key, children);
    } else {
      queue.push({
        type: 'mount',
        key,
        children
      });
    }

    return key;
  };

  const update = (key, children) => {
    if (managerRef.current) {
      managerRef.current.update(key, children);
    } else {
      const op = {
        type: 'mount',
        key,
        children
      };
      const index = queue.findIndex(o => o.type === 'mount' || o.type === 'update' && o.key === key);

      if (index > -1) {
        queue[index] = op;
      } else {
        queue.push(op);
      }
    }
  };

  const unmount = key => {
    if (managerRef.current) {
      managerRef.current.unmount(key);
      removeKey(key);
    } else {
      queue.push({
        type: 'unmount',
        key
      });
    }
  };

  return /*#__PURE__*/React.createElement(Context.Provider, {
    value: {
      mount,
      update,
      unmount
    }
  }, /*#__PURE__*/React.createElement(_reactNative.View, {
    style: [{
      flex: 1
    }, style],
    collapsable: false,
    pointerEvents: "box-none"
  }, children), /*#__PURE__*/React.createElement(_manager.Manager, {
    ref: managerRef
  }));
};

exports.Host = Host;
//# sourceMappingURL=host.component.js.map