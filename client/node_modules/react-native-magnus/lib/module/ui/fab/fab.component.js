function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import * as React from 'react';
import { Animated, TouchableOpacity, LayoutAnimation } from 'react-native';
import color from 'color';
import { getThemeColor } from '../../theme/theme.service';
import { getStyle } from './fab.style';
import { ThemeContext } from '../../theme';
import { Button } from '../button/button.component';
import { Icon } from '../icon/icon.component';
import { withDefaultProps } from '../../utilities/withDefaultProps';

class FabBase extends React.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "animation", void 0);

    _defineProperty(this, "fadeAnimation", void 0);

    _defineProperty(this, "visibleAnimation", void 0);

    _defineProperty(this, "actionsAnimation", void 0);

    _defineProperty(this, "mainBottomAnimation", void 0);

    _defineProperty(this, "actionsBottomAnimation", void 0);

    _defineProperty(this, "getIcon", () => {
      const {
        active
      } = this.state;
      const {
        icon,
        color: colorProp,
        fontSize,
        activeIcon
      } = this.props;

      if (active === false) {
        if (typeof icon === 'string') {
          return /*#__PURE__*/React.createElement(Icon, {
            name: icon,
            fontSize: fontSize,
            color: colorProp
          });
        }

        if ( /*#__PURE__*/React.isValidElement(icon)) {
          return icon;
        }
      } else {
        if (typeof activeIcon === 'string') {
          return /*#__PURE__*/React.createElement(Icon, {
            name: activeIcon,
            fontSize: fontSize,
            color: colorProp
          });
        }

        if ( /*#__PURE__*/React.isValidElement(activeIcon)) {
          return activeIcon;
        }
      }

      return false;
    });

    _defineProperty(this, "reset", () => {
      const {
        animated,
        onClose,
        h,
        bottom,
        useNativeDriver = false
      } = this.props;

      if (animated) {
        Animated.spring(this.animation, {
          toValue: 0,
          useNativeDriver: useNativeDriver
        }).start();
        Animated.spring(this.actionsAnimation, {
          toValue: 0,
          useNativeDriver
        }).start();
        Animated.spring(this.actionsBottomAnimation, {
          toValue: (h ?? 40) + (bottom ?? 40),
          useNativeDriver
        }).start();
      }

      this.updateState({
        active: false
      }, () => {
        if (onClose) {
          onClose();
        }
      });
    });

    _defineProperty(this, "animateButton", () => {
      const {
        animated,
        onOpen,
        h,
        bottom,
        useNativeDriver = false
      } = this.props;
      const {
        active
      } = this.state;

      if (!active) {
        if (animated) {
          Animated.spring(this.animation, {
            toValue: 1,
            useNativeDriver
          }).start();
        }

        if (animated) {
          Animated.spring(this.actionsAnimation, {
            toValue: 1,
            useNativeDriver
          }).start();
          Animated.spring(this.actionsBottomAnimation, {
            toValue: (h ?? 40) + (bottom ?? 40) + 20,
            useNativeDriver
          }).start(); // only execute it for the background to prevent extra calls

          LayoutAnimation.configureNext({
            duration: 180,
            create: {
              type: LayoutAnimation.Types.easeInEaseOut,
              property: LayoutAnimation.Properties.opacity
            }
          });
        }

        this.updateState({
          active: true
        }, () => {
          if (onOpen) {
            onOpen();
          }
        });
      } else {
        this.reset();
      }
    });

    _defineProperty(this, "updateState", (nextState, callback) => {
      this.setState(nextState, () => {
        if (callback) {
          callback();
        }
      });
    });

    _defineProperty(this, "handlePressBackdrop", () => {
      const {
        onPressBackdrop
      } = this.props;

      if (onPressBackdrop) {
        onPressBackdrop();
      }

      this.reset();
    });

    _defineProperty(this, "handlePressItem", () => {
      this.reset();
    });

    _defineProperty(this, "renderMainButton", computedStyles => {
      const {
        animated,
        position,
        right,
        bottom,
        // shadow,
        // shadowColor,
        ...rest
      } = this.props;
      const {
        active
      } = this.state;
      let animatedViewStyle;
      let animatedVisibleView;

      if (animated) {
        animatedVisibleView = {
          opacity: this.fadeAnimation
        };
        animatedViewStyle = {
          opacity: this.fadeAnimation,
          transform: [{
            rotate: this.animation.interpolate({
              inputRange: [0, 1],
              outputRange: ['0deg', '180deg']
            })
          }]
        };
      } else if (active) {
        animatedVisibleView = {};
        animatedViewStyle = {
          opacity: this.fadeAnimation,
          transform: [{
            rotate: '45deg'
          }]
        };
      } else {
        animatedVisibleView = {};
        animatedViewStyle = {
          transform: [{
            rotate: '0deg'
          }]
        };
      }

      return /*#__PURE__*/React.createElement(Animated.View, {
        style: [computedStyles.button, animatedVisibleView],
        accessible: true,
        accessibilityLabel: "Floating Action Button"
      }, /*#__PURE__*/React.createElement(Button, _extends({
        mb: bottom,
        mr: right,
        onPress: this.animateButton
      }, rest), /*#__PURE__*/React.createElement(Animated.View, {
        style: [animatedViewStyle]
      }, this.getIcon())));
    });

    _defineProperty(this, "renderActions", computedStyle => {
      const {
        animated,
        right,
        children
      } = this.props;
      const {
        active
      } = this.state;
      let animatedActionsStyle;

      if (animated) {
        animatedActionsStyle = {
          opacity: this.actionsAnimation.interpolate({
            inputRange: [0, 1],
            outputRange: [0, 1]
          })
        };
      } else {
        animatedActionsStyle = {
          opacity: active ? 1 : 0
        };
      }

      const actionsStyles = [computedStyle.actions, animatedActionsStyle, {
        right,
        bottom: this.actionsBottomAnimation
      }];
      return /*#__PURE__*/React.createElement(Animated.View, {
        style: actionsStyles,
        pointerEvents: "box-none"
      }, React.Children.map(children, child => {
        return /*#__PURE__*/React.cloneElement(child, {
          mb: child.props.mb ? child.props.mb : 'lg',
          onPress: e => {
            // if fab is not active, don't allow pressing buttons
            if (!active) {
              return;
            }

            if (child.props.onPress) {
              child.props.onPress(e);
            }

            this.reset();
          }
        });
      }));
    });

    _defineProperty(this, "renderTappableBackground", (theme, computedStyle) => {
      const {
        overlayColor,
        overlayOpacity
      } = this.props;
      const calculatedOverlayColor = color(getThemeColor(theme.colors, overlayColor)).alpha(overlayOpacity ?? 1).rgb().string(); // TouchableOpacity don't require a child

      return /*#__PURE__*/React.createElement(TouchableOpacity, {
        activeOpacity: 1,
        style: [computedStyle.overlay, {
          backgroundColor: calculatedOverlayColor
        }],
        onPress: this.handlePressBackdrop
      });
    });

    this.state = {
      active: false
    };
    this.mainBottomAnimation = new Animated.Value(props.bottom ?? 0);
    this.actionsBottomAnimation = new Animated.Value((props.h ?? 40) + (props.bottom ?? 40) + 30);
    this.animation = new Animated.Value(0);
    this.actionsAnimation = new Animated.Value(0);
    this.visibleAnimation = new Animated.Value(0);
    this.fadeAnimation = new Animated.Value(1);
  }

  componentDidMount() {
    const {
      openOnMount
    } = this.props;

    if (openOnMount) {
      this.animateButton();
    }
  }

  render() {
    const {
      active
    } = this.state;
    const {
      showBackground
    } = this.props;
    return /*#__PURE__*/React.createElement(ThemeContext.Consumer, null, _ref => {
      let {
        theme
      } = _ref;
      const computedStyle = getStyle(theme, this.props);
      return /*#__PURE__*/React.createElement(Animated.View, {
        pointerEvents: 'box-none',
        style: computedStyle.overlay
      }, active && showBackground && this.renderTappableBackground(theme, computedStyle), this.renderActions(computedStyle), this.renderMainButton(computedStyle));
    });
  }

}

const Fab = withDefaultProps(FabBase, 'Fab', {
  color: 'white',
  fontSize: '4xl',
  p: 18,
  overlayColor: 'gray900',
  overlayOpacity: 0.5,
  position: 'absolute',
  openOnMount: false,
  showBackground: true,
  animated: true,
  bottom: 30,
  right: 30,
  icon: 'plus',
  activeIcon: 'close',
  rounded: 'circle',
  bg: 'blue500',
  useNativeDriver: false,
  shadow: 'lg',
  shadowColor: 'gray900'
});
export { Fab };
//# sourceMappingURL=fab.component.js.map